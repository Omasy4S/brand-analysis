# Архитектура и объяснение решений

## Почему код написан именно так

### Общая структура

Проект разделен на два основных модуля:
- **main.py** - точка входа, работа с аргументами и файлами
- **reports.py** - логика формирования отчетов

Это разделение позволяет легко тестировать логику отчетов отдельно от ввода-вывода.

### main.py

**Почему используется argparse:**
- Стандартная библиотека Python для работы с аргументами командной строки
- Автоматически генерирует help-сообщения
- Валидирует обязательные параметры

**Почему Path из pathlib:**
- Более современный способ работы с путями, чем os.path
- Метод `.exists()` понятнее, чем `os.path.exists()`
- Кроссплатформенность

**Почему csv.DictReader:**
- Возвращает каждую строку как словарь с ключами из заголовка
- Не нужно вручную парсить заголовки и индексы
- Код становится читаемым: `item['brand']` вместо `item[1]`

**Почему sys.exit(1) при ошибках:**
- Стандартный способ сообщить операционной системе об ошибке
- Код возврата 1 означает ошибку (0 - успех)
- Позволяет использовать скрипт в shell-скриптах с проверкой результата

**Почему tabulate:**
- Единственная внешняя библиотека для вывода (разрешена в задании)
- Красивый вывод таблиц в консоль
- Простой API: передаешь список словарей - получаешь таблицу

### reports.py

**Почему НЕ используется абстрактный класс (ABC):**
- Для одного отчета это переусложнение
- Абстрактные классы нужны, когда есть строгий контракт между модулями
- Здесь достаточно простого соглашения: класс должен иметь метод `generate()`
- Если добавится второй отчет - паттерн уже понятен из первого

**Почему классы для отчетов:**
- Каждый отчет - отдельная логика
- Легко добавить новый отчет: создал класс, добавил в словарь
- Можно добавить состояние в класс, если понадобится (например, параметры отчета)

**Почему словарь AVAILABLE_REPORTS:**
- Простой реестр всех отчетов
- Легко проверить, существует ли отчет: `report_name in AVAILABLE_REPORTS`
- Легко получить список доступных отчетов для сообщения об ошибке
- Добавление нового отчета = одна строка в словаре

**Почему функция get_report():**
- Единая точка получения отчета
- Централизованная обработка ошибок
- Скрывает детали работы со словарем от main.py

### Что НЕ сделано намеренно

**Не используется pandas:**
- Задание запрещает использовать pandas
- csv из стандартной библиотеки достаточно для задачи

**Не используется dataclass:**
- Для простых словарей это избыточно
- Словари понятны любому Python-разработчику
- Не нужна валидация типов на уровне данных

**Не используется logging:**
- Для простого скрипта print() достаточно
- logging добавил бы конфигурацию и усложнил код
- Все ошибки выводятся понятными сообщениями

**Не используется type hints везде:**
- Используются только там, где это помогает понять код
- Не используются для простых переменных внутри функций
- Баланс между типизацией и читаемостью
